/*
 * Created on Apr 2, 2003
*/
package org.medi8.internal.core.model;

import java.util.Iterator;
import java.util.Vector;

import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.medi8.internal.core.model.events.MarkerChangeEvent;
import org.medi8.internal.core.model.events.NewTrackEvent;
import org.medi8.internal.core.model.events.SyntheticLengthChangeEvent;

/**
 * A Sequence is basically a collection of Tracks.
 * Conceptually, all Tracks in a sequence play simultaneously.
 */
public class Sequence implements Visitable
{
	/**
	 * Create a new Sequence object.
	 */
	public Sequence()
	{
		videotracks = new Vector();
		automationtracks = new Vector();
		tracks = new Vector();
		listeners = new Vector();
		markers = new Vector();
	}
	
	public void addTrack(Track track)
	{
		tracks.add(track);
		if (track instanceof AutomationTrack)
		  automationtracks.add(track);
		else if (track instanceof VideoTrack)
		  videotracks.add(track);
		// FIXME else throw some internal exception.
		track.addChangeNotifyListener(new IChangeListener () {
			public void notify(Medi8Event event) {
				// A synthetic length change event is generated by
				// updateSizes().
				if (! (event instanceof SyntheticLengthChangeEvent))
					updateSizes();
			}
		});
		updateSizes();
		notify(new NewTrackEvent(this, track));
	}
	
	public Iterator getIterator()
	{
		return tracks.iterator();
	}
	
	public Iterator getMarkerIterator()
	{
	  return markers.iterator();
	}
	
	public void addChangeNotifyListener(IChangeListener listener)
	{
		listeners.add(listener);
	}
	
	/**
	 * Remove a change listener.
	 * @param listener  The listener to remove
	 */
	public void removeChangeNotifyListener(IChangeListener listener)
	{
		listeners.remove(listener);
	}
	
	private void notify(Medi8Event event)
	{
		for (int i = listeners.size() - 1; i >= 0; --i)
		{
			IChangeListener cl = (IChangeListener) listeners.get(i);
			cl.notify(event);
		}
	}
	
	public void visit (Visitor v)
	{
		v.visit(this);
	}
	
	public void visitChildren (Visitor v)
	{
		for (int i = 0; i < videotracks.size(); ++i)
		{
			v.visit((VideoTrack) videotracks.get(i));
		}
		for (int i = 0; i < automationtracks.size(); ++i)
			{
				v.visit((AutomationTrack) automationtracks.get(i));
			}
	}

	/**
	 * This is a helper function to create a new Command which
	 * can be used to introduce a simple cut transition between
	 * two tracks at a given time.
	 * FIXME: this is only here because there didn't seem to be a
	 * better place to put it.
	 * @param track1
	 * @param track2
	 * @param when
	 * @return
	 */
	public static Command createSimpleTransitionCommand (VideoTrack track1,
	                                                     VideoTrack track2,
	                                                     Time time)
	{
      // When the user double-clicks on a conflict marker,
      // we introduce a transition at the conflict point.
      // Operationally this means inserting a split into both
      // tracks at the conflict point, then wrapping the old
      // incoming and outgoing clips with a DeadClip.
      CompoundCommand compound = new CompoundCommand ("dual split");

      // Find the starting clip.
      Clip c1 = track1.findClipAfter(time);
      Time t1 = track1.findClipTime(c1);
      Clip c2 = track2.findClipAfter(time);
      Time t2 = track2.findClipTime(c2);
      boolean firstLive = t1.compareTo(t2) <= 0;

      // First introduce splits into the tracks.
      compound.add(new SplitCommand ("split", track1, time));
      compound.add(new SplitCommand ("split", track2, time));
      // Now kill the old in/out sections.
      compound.add(new KillBeforeCommand("kill before", 
                                         firstLive ? track2 : track1,
                                                   time));
      compound.add(new KillAfterCommand("kill after",
                                        firstLive ? track1 : track2,
                                                  time));

      return compound;
	}

	// FIXME: this exists so that rendering looks right.
	// In particular so that there is blank space after a track.
	// This should be handled by the Figure, not here!
	void updateSizes ()
	{
		// This is inefficient...
		Time max = null;
		for (int i = 0; i < tracks.size(); ++i)
		{
			Track t = (Track) tracks.get(i);
			Time n = t.getLength();
			if (n != null)
			  if (max == null || n.compareTo(max) > 0)
			    max = n;
		}
		if (max.zero())
		{
			// We want to display something in this case.
			// Use two hours.
			max = new Time(2 * 60 * 60);
		}
		for (int i = 0; i < tracks.size(); ++i)
		{
			Track t = (Track) tracks.get(i);
			t.setLength(max);
		}
		
		searchForConflicts();
	}
	
	// Find the earliest starting time of a set of edges.
	Time findMinimum (Edge[] edges)
	{
	  Time result = null;
	  for (int i = 0; i < edges.length; ++i)
	  {
	    if (edges[i] != null
	        && (result == null || edges[i].when.compareTo(result) < 0))
	      result = edges[i].when;
	  }
	  return result;
	}
	
	void updateOneEdge (int slot, Iterator[] iterators, Edge[] current)
	{
	  if (iterators[slot] != null)
	  {
	    Edge next;
	    do
	    {
	      if (! iterators[slot].hasNext())
	      {
	        next = null;
	        iterators[slot] = null;
	        break;
	      }
	      next = (Edge) iterators[slot].next();
	      if (next.clip instanceof EmptyClip || next.clip instanceof DeadClip)
	        next = null;
	    }
	    while (next == null);
	    current[slot] = next;
	  }
	}
	
	boolean updateActive (Time when, Edge[] active, Iterator[] iterators, 
	                      Edge[] current)
	{
	  // First, drop all active clips that are ending.
	  boolean anyActive = false;
	  boolean anyStarting = false;
	  boolean anyIterators = false;
	  boolean[] starts = new boolean[active.length];
	  for (int i = 0; i < active.length; ++i)
	  {
	    if (current[i] != null && when.equals(current[i].when))
	    {
	      if (! current[i].isStarting)
	      {
	        // We're at the end of some clip, so drop it from
	        // the active list and advance the corresponding iterator.
	        active[i] = null;
	        updateOneEdge(i, iterators, current);
	      }
	      else
	      {
	        anyStarting = true;
	        starts[i] = true;
	      }
	    }
	    if (active[i] != null)
	      anyActive = true;
	    if (iterators[i] != null)
	      anyIterators = true;
	  }
	  
	  for (int i = 0; i < active.length; ++i)
	  {
	    if (starts[i])
	    {
	      active[i] = current[i];
	      if (anyActive)
	      {
	        // FIXME: search for the other track.
	        markers.add (new ConflictMarker ((VideoTrack) tracks.get(i), null,
	                                         active[i].when));
	      }
	      updateOneEdge(i, iterators, current);
	    }
	  }
	  
	  return anyIterators;
	}
	
	void searchForConflicts ()
	{
	  markers.clear();

	  Iterator[] iterators = new Iterator[tracks.size ()];
	  for (int i = 0; i < tracks.size (); ++i)
	  {
	    if (tracks.get (i) instanceof VideoTrack)
	      iterators[i] = new EdgeIterator (((VideoTrack) tracks.get(i)).getIterator());
	  }

	  Edge[] active = new Edge[tracks.size ()];
	  Edge[] currentEdges = new Edge[tracks.size ()];

	  for (int i = 0; i < currentEdges.length; ++i)
	    updateOneEdge(i, iterators, currentEdges);

	  while (true)
	  {
	    Time now = findMinimum(currentEdges);
	    if (now == null)
	      break;
	    if (! updateActive(now, active, iterators, currentEdges))
	      break;
	  }
	  
	  // FIXME: only fire if it really changed.
	  notify(new MarkerChangeEvent (this));
	}

	/**
	 * This represents an edge of a clip, either the starting edge
	 * or the trailing edge. 
	 */
	static class Edge
	{
	  Time when;
	  boolean isStarting;
	  Clip clip;
	}

	/**
	 * This class wraps a track's iterator and returns a sequence
	 * of edge objects. 
	 */
	static class EdgeIterator implements Iterator
	{
	  Clip currentClip;
	  Time now = new Time (0);
	  Iterator trackIterator;
	  
	  public EdgeIterator (Iterator it)
	  {
	    trackIterator = it;
	  }

	  public boolean hasNext()
	  {
	    if (currentClip != null)
	      return true;
	    return trackIterator.hasNext();
	  }
	  
	  public Object next()
	  {
	    Edge result = new Edge ();
	    if (currentClip != null)
	    {
	      now = new Time (now, currentClip.getLength());
	      result.isStarting = false;
	      result.clip = currentClip;
	      currentClip = null;
	    }
	    else
	    {
	      currentClip = (Clip) trackIterator.next ();
	      result.clip = currentClip;
	      result.isStarting = true;
	    }
	    result.when = now;
	    return result;
	  }
	  
	  public void remove()
	  {
	    // Nothing.
	  }
	}

	/**
	 * This represents a conflict point.
	 * FIXME: should be a real marker.
	 */
	public static class ConflictMarker
	{
	  public VideoTrack track1;
	  public VideoTrack track2;
	  public Time when;

	  public ConflictMarker (VideoTrack track1, VideoTrack track2, Time when)
	  {
	    this.track1 = track1;
	    this.track2 = track2;
	    this.when = when;
	  }
	}

	/**
	 * All the video tracks we contain.
	 */
	private Vector videotracks;
	
	/**
	 * All the automation tracks we contain.
	 */
	private Vector automationtracks;
	
	/**
	 * All the tracks we contain.
	 */
	private Vector tracks;
	
	/**
	 * All event listeners.
	 */
	private Vector listeners;
	
	/**
	 * All markers we manage.
	 */
	private Vector markers;
	
	/**
	 * FPS for this sequence.  -1 if not known.
	 */
	private int fps = -1;
}
